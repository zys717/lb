
### 1. 元数据粒度：仅文本+Tags，还是加硬阈值？

**建议：必须加硬阈值字段（Structured Assertions）。**

* **理由** ：你的项目核心竞争力在于“可验证性” (Verification)。
* **现状** ：在 `S001-S020` 中，你通过 Python 脚本直接计算物理违规（如 `detect_violations.py`），这是你的“护城河”。
* **问题** ：在 `S021-S049` 中，目前的 `extra_rule` 只是文本提示。如果 LLM 忽略了“10% 电量”这个文本，你很难自动化检测它是否犯错。
* **方案** ：在 `guidelines.jsonl` 中引入 **"Assertion"（断言）** 字段。

  **结构示例 (guidelines.jsonl)：**
  **JSON**

```
  {
    "id": "RULE_BATTERY_MIN_RESERVE",
    "text": "Decision rule: Enforce 10% reserve; business pressure do NOT override safety.",
    "tags": ["battery", "safety", "S027", "S021"],
    "scope": "operational",
    "structured_assertion": {
       "parameter": "battery_margin",
       "operator": ">=",
       "value": 0.10,
       "unit": "percent"
    }
  }
```

* **收益** ：

1. **RAG 阶段** ：把 `text` 喂给 LLM 做推理。
2. **Post-Check 阶段** ：你可以写一个通用的 `validator.py`，读取检索到的 `structured_assertion`，直接用 Python 校验 LLM 的决策是否违反了硬阈值。这样你就把 `S001` 的“物理验证”能力扩展到了 `S021` 的“逻辑验证”领域。

### 2. 向量库选型与离线/在线更新流程

**建议：轻量级本地库（Chroma/FAISS） + 离线构建（Offline Build）。**

* **选型** ：推荐 **ChromaDB** 或  **FAISS** 。
* 考虑到你的规则数量级（49个场景 x 3-5条规则 ≈ 200条），数据量极小。
* **ChromaDB** 的优势在于它对 Metadata 过滤（如 `filter={"scope": "medical"}`）支持更好。你可以先按场景标签（Tags）粗筛，再按语义精排。
* **更新流程** ： **离线构建（CI/CD Pipeline）** 。
* **原因** ：低空经济的法规（Regulation）和 SOP 是相对静态的，不会每秒钟变一次。
* **Workflow** ：
  1. 开发者更新 `guidelines.jsonl`（这是 Source of Truth）。
  2. 运行 `build_guideline_index.py` 生成/更新本地向量索引文件（如 `index.bin` 或 `chroma.sqlite3`）。
  3. 提交代码。
  4. 运行时，`run_rag_batch.py` 以**只读模式**加载索引。
* **注意** ：不需要在线更新（Online Update）。除非你打算做一个“在对话中学习新规则”的系统（这对于安全关键系统来说风险太大）。

### 3. 模板选择：保留 ID 路由，还是上分类器？

**建议：采用“混合路由策略” —— ID 决定结构，检索决定内容。**

* **保留 ID 路由用于 Prompt 模板（Schema）** ：
* **理由** ：`S049`（资本分配）和 `S021`（电池）需要的**输入字段**完全不同（一个是 IRR/NPV，一个是 SOC/Wind）。让 LLM 或分类器去猜“用哪个 JSON 模板”极其容易出错。
* 既然你在跑 Benchmark，输入本身就是带 ID 的，利用这个先验知识保证**输入数据的完整性**是工程上的最优解。
* **使用检索用于规则内容（Policy）** ：
* **做法** ：在 `build_prompt` 函数内部，保留根据 ID 选择 `base_prompt`（如 `build_capital_allocation_prompt`）的逻辑，但在填充 `rag_block` 时，不再使用 `if-elif` 硬编码 `extra_rule`，而是调用检索器。
* **代码逻辑示意** ：
  **Python**

  ```
  # 1. 确定结构 (保留确定性)
  if scenario_id.startswith("S049"):
      base_prompt = build_capital_allocation_prompt(...)

  # 2. 确定逻辑 (引入泛化性)
  # 用 scenario_description 去向量库查“应该遵循什么原则”
  relevant_guidelines = retriever.search(query=scenario_data['description'], top_k=3)
  rag_rules_text = "\n".join([g.text for g in relevant_guidelines])

  # 3. 组装
  final_prompt = base_prompt + "\nRelevant Rules:\n" + rag_rules_text
  ```
* **收益** ：如果未来来了个 `S050`（它是 S021 的变体），你只需复用 S021 的模板，RAG 会自动检索到“电池相关规则”，而不需要你重写 `if-elif` 逻辑。

### 总结

你的改进方案非常扎实。我的建议核心在于：**不要丢掉你现有的确定性优势（ID路由、Python计算），而是用 RAG 去替换掉最不灵活的“硬编码文本”部分，并顺便把“规则验证”给标准化了。**
